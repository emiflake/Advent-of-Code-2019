{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RecordWildCards #-}

module Solution where

import qualified Data.Text as T
import Common
import Test.Hspec
import Data.List
import Control.Monad.Writer
import qualified Control.Monad.State as ST
import qualified Data.Map as Map
import Data.Map (Map)
import Data.Set (Set)
import qualified Data.Set as Set
import Linear
import Control.Lens
import Data.Ord
import Data.Maybe
import qualified Graphics.Image as I
import Text.Pretty.Simple
import qualified Graphics.Gloss as G
import qualified Graphics.Gloss.Interface.IO.Interact as G
import Control.Concurrent
import Text.Parsec
import Debug.Trace
import Data.Char
import Text.Parsec.String

pattern :: Int -> [Integer]
pattern n = tail . cycle $ concatMap (replicate (fromIntegral n)) pat
    where pat = [0, 1, 0, -1]

digits :: Integer -> [Integer]
digits = fmap (fromIntegral . digitToInt) . show


fft :: Int -> Integer -> Integer
fft origL i = read . concatMap show $ fmap (\m -> (`mod`10) . abs $ sum (zipWith (*) m digs)) multipls
    where len = length $ digits i
          digs = replicate (origL - len) 0 ++ digits i
          multipls = fmap (take origL . pattern) [1..origL]

one :: SolutionF Integer
one t = do
    let num = (read $ T.unpack t) :: Integer
        len = length $ show num

    pure . read . take 8 . show . (!!100) $ iterate (fft len) num

two :: SolutionF Integer
two t = do
    let num = (read $ T.unpack t) :: Integer
        len = length $ show num
        offset = (read . take 7 $ T.unpack t) :: Int
        digs = digits num
        eight = (read . concatMap show . take 400 . drop (offset - 200) $ cycle digs) :: Integer

    liftIO . pPrint $ eight

    let fft' :: Int -> Integer -> Integer
        fft' origL i = read . concatMap show $ fmap (\m -> (`mod`10) . abs $ sum (zipWith (*) m digs)) multipls
            where len = length $ digits i
                  digs = replicate (origL - len) 0 ++ digits i
                  multipls = fmap (take origL . drop (offset - 200) . pattern) [1..origL]

    liftIO . pPrint . (!!100) $ iterate (fft' 400) eight

    pure 2
    -- Should be 84462026

    -- tried 33456410 (>)
    -- tried 79800460 (~)
    -- tried 83774821 (<)

tests :: IO ()
tests = hspec $ pure ()

solution :: Solution Integer Integer
solution = MkSolution { day = 14
                      , part1 = one
                      , part2 = two
                      , testSpec = tests
                      }
